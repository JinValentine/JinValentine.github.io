---
layout: single
title: "[그리디] 이코테 - 볼링공 고르기"
categories: Algorithm
---

## 경우의 수를 구하는 그리디 알고리즘 문제

## 문제

A, B 두 사람이 볼링을 치고 있습니다. 두 사람은 서로 무게가 다른 볼링공을 고르려고 합니다. 볼링공은 총 N개가 있으며 각 볼링공마다 무게가 적혀 있고, 공의 번호는 1번부터 순서대로 부여됩니다. 또한 같은 무게의 공이 여러개 있을 수 있지만, 서로 다른 공으로 간주합니다. 볼링공의 무게는 1부터 M까지의 자연수 형태로 존재합니다. 두 사람이 볼링공을 고르는 경우의 수를 구하는 프로그램을 작성하세요

#### 입력 조건

- 첫째 줄에 볼링공의 개수 N, 공의 최대 무게 M이 공백으로 구분되어 각각 자연수 형태로 주어집니다. (1 <= N <= 1,000, 1<=M<=1000)
- 둘째 줄에 각 볼링공의 무게 K가 공백으로 구분되어 순서대로 자연수 형태로 주어집니다. (1 <= K <= M)

#### 출력 조건

- 첫째 줄에 두 사람이 볼링공을 고르는 경우의 수를 출력합니다.

#### 입력 예시

```python
5 3
1 3 2 3 2
```

#### 출력 예시

```python
8
```

---

### 나의 풀이

```python
n, m = map(int, input().split())

data = list(map(int, input().split()))

data.sort()

result = 0

for x in range(n):
    for y in range(n):
        if data[x] < data[y]:
            result += 1

print(result)
```

### 책의 풀이

```python
n, m = map(int, input().split())
data = list(map(int, input().split()))

# 1부터 10까지의 무게를 담을 수 있는 리스트
array = [0] * 11

for x in data:
    # 각 무게에 해당하는 볼링공의 개수 카운트
    array[x] += 1

print(array)
result = 0
# 1부터 m까지의 각 무게에 대하여 처리
for i in range(1, m + 1):
    n -= array[i] # 무게가 i인 볼링공의 개수 (A가 선택할 수 있는 개수) 제외
    result += array[i] * n # B가 선택하는 경우의 수와 곱하기

print(result)
```

현재 상황에서 가장 좋아 보이는 것만을 선택하는 **그리즈 알고리즘**의 문제이다. 내가 했던 풀이와 책의 풀이가 많이 다르다. 우선 나의 풀이도 입력 예제들을 모두 입력해보니 답은 모두 맞게 나와서 정답을 확인해보았다. 책의 풀이에서는 입력조건에 공의 최대무게인 m을 입력받도록 되어있는데 나의 풀이에서는 m을 활용하지 않았기 때문에 사실 책에서 제공하는 풀이가 더 올바른 방식인 것을 알 수 있었다.

---

### 참조

이것이 취업을 위한 코딩 테스트다 with 파이썬 (한빛미디어, 나동빈)
